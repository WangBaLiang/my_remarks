<!DOCTYPE HTML>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta name="Keywords" content="blog"/>
    <meta name="Description" content="blog"/>
    <title>Simple</title>
    <link rel="shortcut icon" href="/static/favicon.png"/>
    <link rel="stylesheet" type="text/css" href="/main.css" />
</head>
<body>
<div class="main">
    <div class="header">
    	<ul id="pages">
            <li><a href="/">home</a></li>
            <li><a href="/#/tags">tags</a></li>
            <li><a href="/#/archive">archive</a></li>
    	</ul>
    </div>
	<div class="wrap-header">
	<h1>
    <a href="/" id="title"></a>
	</h1>
	</div>
<div id="md" style="display: none;">
<!-- markdown -->
#[数据库性能优化之SQL语句](http://blog.jobbole.com/96996/)
##操作符优化
1. IN 操作符
    * 先尝试转换成多个表连接，若转换不成功，执行in中的子查询，再执行外层查询；若转换成功，直接采用多表连接方式查询
    * 在业务密集的SQL当中尽量不采用IN操作符
    * _推荐_：用EXISTS 方案代替。
2. NOT IN操作符
    * 不能应用表的索引，不推荐使用
    * _推荐_：用NOT EXISTS 方案代替
3. IS NULL 或IS NOT NULL操作符
    * 索引不索引空值，不能用null做索引，任何包含null的列都不会被包含在索引
    * 任何在where子句中使用is null或is not null的语句优化器是不允许使用索引的。
    * _推荐_：
        * 用其它相同功能的操作运算代替，如：a is not null 改为 a>0 或a>’’等；          
        * 不允许字段为空，而用一个缺省值代替空值。
4. > 及 < 操作符（大于或小于操作符）
    * 执行A>2与A>=3，A>2会先找出为2的记录索引再进行比较，A>=3则直接找到=3的记录索引。
5. LIKE操作符
    * 通配符“*”在搜索词首出现，Oracle不会使用last_name的索引
    * LIKE ‘%5400%’ 这种查询不会引用索引，而是全表查询，而LIKE ‘X5400%’则会引用范围索引
6. UNION操作符

        select * from gc\_dfys 
        union 
        select * from ls\_jg_dfys

    * 这个SQL在运行时先取出两个表的结果，再用排序空间进行排序删除重复的记录，最后返回结果集，如果表数据量大的话可能会导致用磁盘进行排序。

        select * from gc_dfys 
        union all 
        select * from ls_jg_dfys

    * _推荐_：采用UNION ALL操作符替代UNION，因为UNION ALL操作只是简单的将两个结果合并后就返回。   

7. 联接列
    * 对于有联接的列，即使最后的联接值为一个静态值，优化器是不会使用索引的。我们一起来看一个例子，假定有一个职工表(employee)，对于一个职工的姓和名分成两列存放(FIRST\_NAME和LAST\_NAME)，现在要查询一个叫比尔.克林顿(Bill Cliton)的职工。  

        select * from employss where first\_name||''||last\_name ='Beill Cliton';

    * 使用上述SQL，系统优化器对基于last\_name创建的索引没有使用，_推荐使用下列语法_：

         where first_name ='Beill' and last_name ='Cliton';


8. Order by语句    
    * 在Order by语句的非索引项或者有计算表达式都将降低查询速度。
    * 重写order by语句以使用索引，也可以为所使用的列建立另外一个索引，同时应绝对避免在order by子句中使用表达式

9. NOT

        select * from employee where salary <> 3000;

        select * from employee where salary<3000 or salary>3000;
    * 第二种查询方案会比第一种查询方案更快些
    * 第二种查询允许Oracle对salary列使用索引，而第一种查询则不能使用索引

##SQL书写注意
1. 不同写法的SQL，如

        Select * from dlyx.zl_yhjbqk
        Select * from DLYX.ZLYHJBQK
        Select *  from DLYX.ZLYHJBQK
    * 从ORACLE共享内存SGA的原理，可以得出ORACLE对每个SQL 都会对其进行一次分析，并且占用共享内存，
    * 如果将SQL的字符串及格式写得完全相同，则ORACLE只会分析一次，共享内存也只会留下一次的分析结果，这不仅可以减少分析SQL的时间，而且可以减少共享内存重复的信息，ORACLE也可以准确统计SQL的执行频率。

2. WHERE后面的条件顺序
3. 查询表顺序的影响
    * 在FROM后面的表中的列表顺序会对SQL执行性能影响，在没有索引及ORACLE没有对表进行统计分析的情况下，ORACLE会按表出现的顺序进行链接，由此可见表的顺序不对时会产生十分耗服物器资源的数据交叉。（注：如果对表进行了统计分析，ORACLE会自动先进行小表的链接，再进行大表的链接）

##SQL语句索引的利用
1. 对条件字段的一些优化
    * 采用函数处理的字段不能利用索引

            substr(hbs\_bh,1,4)=’5400’，优化处理：hbs\_bh like ‘5400%’
            trunc(sk\_rq)=trunc(sysdate)， 优化处理：sk\_rq>=trunc(sysdate) and sk\_rq<trunc(sysdate+1)

    * 进行了显式或隐式的运算的字段不能进行索引

            ‘X’ || hbs\_bh>’X5400021452’，优化处理：hbs\_bh>’5400021542’
            sk\_rq+5=sysdate，优化处理：sk\_rq=sysdate-5

    * 条件内包括了多个本表的字段运算时不能进行索引

            ys\_df>cx\_df，无法进行优化 
            qc\_bh || kh\_bh=’5400250000’，优化处理：qc\_bh=’5400’ and kh_bh=’250000’

    * 选择最有效率的表名顺序(只在基于规则的优化器中有效)：
        * ORACLE 的解析器按照从右到左的顺序处理FROM子句中的表名，FROM子句中写在最后的表(基础表 driving table)将被最先处理，在FROM子句中包含多个表的情况下,你必须选择记录条数最少的表作为基础表。如果有3个以上的表连接查询, 那就需要选择交叉表(intersection table)作为基础表, 交叉表是指那个被其他表所引用的表.
    * WHERE子句中的连接顺序：
        * ORACLE采用自下而上的顺序解析WHERE子句,根据这个原理,表之间的连接必须写在其他WHERE条件之前, 那些可以过滤掉最大数量记录的条件必须写在WHERE子句的末尾.
    * SELECT子句中避免使用 ‘ * ‘：
       * ORACLE在解析的过程中, 会将’*’ 依次转换成所有的列名, 这个工作是通过查询数据字典完成的, 这意味着将耗费更多的时间。
    




<!-- markdown end -->
</div>
<div class="entry" id="main">
<!-- content -->
<h1 id="sqlhttpblogjobbolecom96996"><a href="http://blog.jobbole.com/96996/">数据库性能优化之SQL语句</a></h1>

<h2 id="">操作符优化</h2>

<ol>
<li>IN 操作符
<ul><li>先尝试转换成多个表连接，若转换不成功，执行in中的子查询，再执行外层查询；若转换成功，直接采用多表连接方式查询</li>
<li>在业务密集的SQL当中尽量不采用IN操作符</li>
<li><em>推荐</em>：用EXISTS 方案代替。</li></ul></li>
<li>NOT IN操作符
<ul><li>不能应用表的索引，不推荐使用</li>
<li><em>推荐</em>：用NOT EXISTS 方案代替</li></ul></li>
<li>IS NULL 或IS NOT NULL操作符
<ul><li>索引不索引空值，不能用null做索引，任何包含null的列都不会被包含在索引</li>
<li>任何在where子句中使用is null或is not null的语句优化器是不允许使用索引的。</li>
<li><em>推荐</em>：
<ul><li>用其它相同功能的操作运算代替，如：a is not null 改为 a&gt;0 或a&gt;’’等；          </li>
<li>不允许字段为空，而用一个缺省值代替空值。</li></ul></li></ul></li>
<li>&gt; 及 &lt; 操作符（大于或小于操作符）
<ul><li>执行A&gt;2与A&gt;=3，A&gt;2会先找出为2的记录索引再进行比较，A&gt;=3则直接找到=3的记录索引。</li></ul></li>
<li>LIKE操作符
<ul><li>通配符“*”在搜索词首出现，Oracle不会使用last_name的索引</li>
<li>LIKE ‘%5400%’ 这种查询不会引用索引，而是全表查询，而LIKE ‘X5400%’则会引用范围索引</li></ul></li>
<li><p>UNION操作符</p>

<pre><code>select * from gc\_dfys 
union 
select * from ls\_jg_dfys
</code></pre>

<ul><li><p>这个SQL在运行时先取出两个表的结果，再用排序空间进行排序删除重复的记录，最后返回结果集，如果表数据量大的话可能会导致用磁盘进行排序。</p>

<p>select * from gc<em>dfys 
union all 
select * from ls</em>jg_dfys</p></li>
<li><p><em>推荐</em>：采用UNION ALL操作符替代UNION，因为UNION ALL操作只是简单的将两个结果合并后就返回。   </p></li></ul></li>
<li><p>联接列</p>

<ul><li><p>对于有联接的列，即使最后的联接值为一个静态值，优化器是不会使用索引的。我们一起来看一个例子，假定有一个职工表(employee)，对于一个职工的姓和名分成两列存放(FIRST_NAME和LAST_NAME)，现在要查询一个叫比尔.克林顿(Bill Cliton)的职工。  </p>

<p>select * from employss where first_name||''||last_name ='Beill Cliton';</p></li>
<li><p>使用上述SQL，系统优化器对基于last_name创建的索引没有使用，<em>推荐使用下列语法</em>：</p>

<p>where first<em>name ='Beill' and last</em>name ='Cliton';</p></li></ul></li>
<li><p>Order by语句    </p>

<ul><li>在Order by语句的非索引项或者有计算表达式都将降低查询速度。</li>
<li>重写order by语句以使用索引，也可以为所使用的列建立另外一个索引，同时应绝对避免在order by子句中使用表达式</li></ul></li>
<li><p>NOT</p>

<pre><code>select * from employee where salary &lt;&gt; 3000;


select * from employee where salary&lt;3000 or salary&gt;3000;
</code></pre>

<ul><li>第二种查询方案会比第一种查询方案更快些</li>
<li>第二种查询允许Oracle对salary列使用索引，而第一种查询则不能使用索引</li></ul></li>
</ol>

<h2 id="sql">SQL书写注意</h2>

<ol>
<li><p>不同写法的SQL，如</p>

<pre><code>Select * from dlyx.zl_yhjbqk
Select * from DLYX.ZLYHJBQK
Select *  from DLYX.ZLYHJBQK
</code></pre>

<ul><li>从ORACLE共享内存SGA的原理，可以得出ORACLE对每个SQL 都会对其进行一次分析，并且占用共享内存，</li>
<li>如果将SQL的字符串及格式写得完全相同，则ORACLE只会分析一次，共享内存也只会留下一次的分析结果，这不仅可以减少分析SQL的时间，而且可以减少共享内存重复的信息，ORACLE也可以准确统计SQL的执行频率。</li></ul></li>
<li><p>WHERE后面的条件顺序</p></li>
<li>查询表顺序的影响
<ul><li>在FROM后面的表中的列表顺序会对SQL执行性能影响，在没有索引及ORACLE没有对表进行统计分析的情况下，ORACLE会按表出现的顺序进行链接，由此可见表的顺序不对时会产生十分耗服物器资源的数据交叉。（注：如果对表进行了统计分析，ORACLE会自动先进行小表的链接，再进行大表的链接）</li></ul></li>
</ol>

<h2 id="sql">SQL语句索引的利用</h2>

<ol>
<li><p>对条件字段的一些优化</p>

<ul><li><p>采用函数处理的字段不能利用索引</p>

<pre><code>substr(hbs\_bh,1,4)=’5400’，优化处理：hbs\_bh like ‘5400%’
trunc(sk\_rq)=trunc(sysdate)， 优化处理：sk\_rq&gt;=trunc(sysdate) and sk\_rq&lt;trunc(sysdate+1)
</code></pre></li>
<li><p>进行了显式或隐式的运算的字段不能进行索引</p>

<pre><code>‘X’ || hbs\_bh&gt;’X5400021452’，优化处理：hbs\_bh&gt;’5400021542’
sk\_rq+5=sysdate，优化处理：sk\_rq=sysdate-5
</code></pre></li>
<li><p>条件内包括了多个本表的字段运算时不能进行索引</p>

<pre><code>ys\_df&gt;cx\_df，无法进行优化 
qc\_bh || kh\_bh=’5400250000’，优化处理：qc\_bh=’5400’ and kh_bh=’250000’
</code></pre></li>
<li><p>选择最有效率的表名顺序(只在基于规则的优化器中有效)：</p>

<ul><li>ORACLE 的解析器按照从右到左的顺序处理FROM子句中的表名，FROM子句中写在最后的表(基础表 driving table)将被最先处理，在FROM子句中包含多个表的情况下,你必须选择记录条数最少的表作为基础表。如果有3个以上的表连接查询, 那就需要选择交叉表(intersection table)作为基础表, 交叉表是指那个被其他表所引用的表.</li></ul></li>
<li>WHERE子句中的连接顺序：
<ul><li>ORACLE采用自下而上的顺序解析WHERE子句,根据这个原理,表之间的连接必须写在其他WHERE条件之前, 那些可以过滤掉最大数量记录的条件必须写在WHERE子句的末尾.</li></ul></li>
<li>SELECT子句中避免使用 ‘ * ‘：
<ul><li>ORACLE在解析的过程中, 会将’*’ 依次转换成所有的列名, 这个工作是通过查询数据字典完成的, 这意味着将耗费更多的时间。</li></ul></li></ul></li>
</ol>
<!-- content end -->
</div>
<br>
<br>
    <div id="disqus_thread"></div>
	<div class="footer">
		<p>© Copyright 2014 by isnowfy, Designed by isnowfy</p>
	</div>
</div>
<script src="main.js"></script>
<script id="content" type="text/mustache">
    <h1>{{title}}</h1>
    <div class="tag">
    {{date}}
    {{#tags}}
    <a href="/#/tag/{{name}}">#{{name}}</a>
    {{/tags}}
    </div>
</script>
<script id="pagesTemplate" type="text/mustache">
    {{#pages}}
    <li>
        <a href="{{path}}">{{title}}</a>
    </li>
    {{/pages}}
</script>
<script>
$(document).ready(function() {
    $.ajax({
        url: "main.json",
        type: "GET",
        dataType: "json",
        success: function(data) {
            $("#title").html(data.name);
            var pagesTemplate = Hogan.compile($("#pagesTemplate").html());
            var pagesHtml = pagesTemplate.render({"pages": data.pages});
            $("#pages").append(pagesHtml);
            //path
            var path = "database_performance_sql.html";
            //path end
            var now = 0;
            for (var i = 0; i < data.posts.length; ++i)
                if (path == data.posts[i].path)
                    now = i;
            var post = data.posts[now];
            var tmp = post.tags.split(" ");
            var tags = [];
            for (var i = 0; i < tmp.length; ++i)
                if (tmp[i].length > 0)
                    tags.push({"name": tmp[i]});
            var contentTemplate = Hogan.compile($("#content").html());
            var contentHtml = contentTemplate.render({"title": post.title, "tags": tags, "date": post.date});
            $("#main").prepend(contentHtml);
            if (data.disqus_shortname.length > 0) {
                var disqus_shortname = data.disqus_shortname;
                (function() {
                    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                })();
            }
        }
    });
});
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ["\\(", "\\)"]], processEscapes: true}});
</script>
</body>
</html>
